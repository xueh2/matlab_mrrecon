function y = soft_4Dwavelet(x,lambda, scale)

% lambda is the regularization parameter
% x is a 4D matrix
%
% scale is a 4x4 matrix composing the weights for different frequencies
% scale(1,1,1,1)=1

if nargin<3
    scale=ones(2,2,2,2);
    
    for i=1:2
        for j=1:2
            for m=1:2
                for n=1:2
                    scale(i,j,m,n)=sqrt(i*j*m*n);
                end
            end
        end
    end
    
    scale(:,:,:,2)=scale(:,:,:,2)*4;
    % put more weight on the temporal direction
end

sizeImageRedundant=size(x);

y=x;

for i=1:2
    for j=1:2
        for m=1:2
            for n=1:2
                z...
                   =max(...
                abs(...
                x( (sizeImageRedundant(1)/2*(i-1) +1):(sizeImageRedundant(1)/2*i -1),...
                   (sizeImageRedundant(2)/2*(j-1) +1):(sizeImageRedundant(2)/2*j -1),...
                   (sizeImageRedundant(3)/2*(m-1) +1):(sizeImageRedundant(3)/2*m -1),...
                   (sizeImageRedundant(4)/2*(n-1) +1):(sizeImageRedundant(4)/2*n -1) ))...
                   - lambda * scale(i,j,m,n),0);
                % compute the norm after soft thresholding
               
                y( (sizeImageRedundant(1)/2*(i-1) +1):(sizeImageRedundant(1)/2*i -1),...
                   (sizeImageRedundant(2)/2*(j-1) +1):(sizeImageRedundant(2)/2*j -1),...
                   (sizeImageRedundant(3)/2*(m-1) +1):(sizeImageRedundant(3)/2*m -1),...
                   (sizeImageRedundant(4)/2*(n-1) +1):(sizeImageRedundant(4)/2*n -1) )...
                   =...
                   z./...
               (z+lambda* scale(i,j,m,n) ).*...
                x( (sizeImageRedundant(1)/2*(i-1) +1):(sizeImageRedundant(1)/2*i -1),...
                   (sizeImageRedundant(2)/2*(j-1) +1):(sizeImageRedundant(2)/2*j -1),...
                   (sizeImageRedundant(3)/2*(m-1) +1):(sizeImageRedundant(3)/2*m -1),...
                   (sizeImageRedundant(4)/2*(n-1) +1):(sizeImageRedundant(4)/2*n -1) );
               % soft thresholding
               
                y( sizeImageRedundant(1)/2*i,...
                   sizeImageRedundant(2)/2*j,...
                   sizeImageRedundant(3)/2*m,...
                   sizeImageRedundant(4)/2*n )...
                   =...
                x( sizeImageRedundant(1)/2*i,...
                   sizeImageRedundant(2)/2*j,...
                   sizeImageRedundant(3)/2*m,...
                   sizeImageRedundant(4)/2*n );
                % keep the last column unchanged
            end
        end
    end
end

% z = max(abs(x) - lambda, 0);
% y = z./(z+lambda) .* x;