function [unmix1d] = ismrm_calculate_senseWithoutFOV_unmixing_1d(acc_factor, csm1d, snr_map1d, alpha)%% function [unmix1d] = ismrm_calculate_senseWithoutFOV_unmixing_1d(acc_factor, csm, verbose)%% Calculates the unmixing coefficients for a single line of aliased images%% INPUT:%       acc_factor  scalar    : Acceleration factor, e.g. 2%       csm1d       [y, coil, 2] : Coil sensitivity map for a single x location%% OUTPUT:%       unmix1d     [y, coil, 2] : Image unmixing coefficients for a single x location %%   Code made available for the ISMRM 2013 Sunrise Educational Course% %   Michael S. Hansen (michael.hansen@nih.gov)%   Philip Beatty (philip.beatty@sri.utoronto.ca)%[ny, nc, ns] = size(csm1d);if mod(ny, acc_factor) ~= 0,    error('ny must be a multiple of acc_factor');endunmix1d = zeros(ny, nc, ns);n_blocks = ny/acc_factor;for index = 1:n_blocks    A1 = csm1d(index:n_blocks:ny,:,1).';    A2 = csm1d(index:n_blocks:ny,:,2).';        snr = snr_map1d(index:n_blocks:ny);    sumA2 = squeeze(sum(A2, 1));        hasA2 = 1;    if ( sum(sumA2)==0 )        A=A1;        hasA2 = 0;    else        A = [A1 A2];        hasA2 = 1;    end        if max(abs(A(:))) > 0,                  snrReg = zeros([size(A,2) size(A,2)]);                        ATA = A'*A;                if ( hasA2 )            M = size(A,2)/2;            for rr=1:M                snrReg(rr, rr) = alpha/(snr(rr)*snr(rr));                snrReg(rr+M, rr+M) = alpha/(snr(rr)*snr(rr));            end        else            for rr=1:size(A,2)                snrReg(rr, rr) = alpha/(snr(rr)*snr(rr));            end        end                        % AT = pinv(A);        % AT = inv_tikhonov_IcePAT(A'*A, 1e-3/2)*A';        % AT = inv_reg(ATA, 1e-3)*A';        AT = inv(ATA+snrReg)*A';                unmix1d(index:n_blocks:ny, :, 1) = AT(1:acc_factor, :);        if ( hasA2 )            unmix1d(index:n_blocks:ny, :, 2) = AT(acc_factor+1:end, :);        end    endend